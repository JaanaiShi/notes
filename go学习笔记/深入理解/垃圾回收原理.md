### 1. 前言

对于Golang来说，所谓的垃圾就是不再需要使用的内存块，这些垃圾如果不清理就没办法再次被利用，在不支持垃圾回收的编程语言里，这些垃圾内存就是泄露的内存。

在Golang中垃圾回收（GC）也是内存管理的一部分

### 2. 垃圾回收算法

常用的垃圾回收算法

* 引用计数：对每个对象维护一个引用计数，当引用该对象的对象被销毁时，引用计数减1，当引用计数器为0时回收该对象。
  * 优点：对象可以很快地被回收，不会出现内存耗尽或达到某个阈值时才回收
  * 缺点：不能很好地处理循环引用，而且实时维护引用计数，也有一定的代价
  * 代表语言：Python、PHP、Swift
* 标记-清除：从**根变量**开始遍历所有引用的对象，引用的对象标记位"被引用"，没有被标记的进行回收。
  * 优点：解决了引用计数的缺点
  * 缺点：需要STW，即要暂时停掉程序运行
  * 代表语言：Golang（其采用三色标记法）
* 分代收集：按照对象生命周期长短划分不同的代空间，生命周期长的放入老年代，而短的放入新生代，不同代有不同的回收算法和回收频率
  * 优点：回收性能好
  * 缺点：算法复杂
  * 代表语言：JAVA

### 3. Golang垃圾回收

#### 3.1 垃圾回收原理

垃圾回收的核心就是标记出那些内存还在使用中（即被引用到），哪些内存不再使用了（即未被引用），把未引用的内存回收掉，以供后续内存分配时使用。

下图展示了一段内存，内存中既有已分配掉的内存，也有未分配的内存，垃圾回收的目标就是把那些已经分配的但没有对象引用的内存找出来并回收掉：

![image-20210818111906798](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210818111906798.png)

上图中，内存块1、2、4号位上的内存块已被分配（数字1代表已被分配，0未分配）。变量a，b为一指针，指向内存的1、2号位。内存块的4号位曾经被使用过，但现在没有任何对象引用了，就需要被回收掉。

垃圾回收开始时从root对象开始扫描，把root对象引用的内存标记为"被引用"，考虑到内存块中存放的可能是指针，所以还需要递归的进行标记，全部标记完成后，只保留被标记的内存，未被标记的全部标识为未分配即完成了回收。

#### 3.3 内存标记（Mark）



