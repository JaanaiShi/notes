## 内存分配原理

### 1.基本策略：

1. 每次从操作系统申请一大块内存（比如1MB），以减少系统调用。
2. 将申请到的大块内存按照特定大小预先切分成小块，构成链表
3. 为对象分配内存时，只须从大小合适的链表提取一个小块即可。
4. 回收对象内存时，将该小块内存重新归还到原链表，以便复用
5. 如闲置内存过多，则尝试归还部分内存给操作系统，降低整体开销。

内存分配器只管理内存块，并不关心对象状态。且它不会主动回收内存，垃圾回收器在完成清理操作后，触发内存分配器的回收操作。

### 2. 内存块

分配器将其管理的内存块分为两种。

* span：由多个地址连续的页（page）组成的大块内存
* object：将span按特定大小切分成多个小块，每个小块可存储一个对象。

按照其用途，span面向内部管理，object面向对象分配。

#### 2.1 span

span是用来管理arena页的关键数据结构，每个span中包含1个或多个连续页，为了满足小对象分配，span中的一页会划分更小的粒度，而对于大对象比如超过页大小，则通过多页实现。

#### 2.2 class

根据对象大小，划分了一系列class，每个class都代表一个固定大小的对象，以及每个span的大小。如图所示：

### 3. 内存分配过程

针对待分配对象的大小不同有不同的分配逻辑

* （0,16B）且不包含指针的对象：Tiny分配
* （0,16B）包含指针的对象：正常分配
* [16B, 32KB]：正常分配
* （32KB，-）：大对象分配

其中Tiny分配和大对象分配都属于内存管理的优化范畴

### 总结

Golang内存分配是个相当复杂的过程，其中还掺杂了GC的处理，这里仅仅对其关键数据结构进行了说明，了解其原理而又不至于深陷实现细节。

1. Golang程序启动时申请一大块内存，并划分成spans、bitmap、arena区域
2. arena区域按页划分成一个个小块
3. span管理一个或多个页
4. mcentral管理多个span供线程申请使用
5. mcache作为线程私有资源，资源来源于mcentral

