### defer

defer语句用于延迟函数的调用，每次defer都会把一个函数压入栈中，函数返回前再把延迟的函数取出并执行

创建defer的函数称为主函数，defer语句后面的函数称为延迟函数。

延迟函数可能有输入参数，这些参数可能来源于定义defer的函数，延迟函数也可能引用主函数用于返回的变量，也就是说延迟函数可能会影响主函数的一些行为

### 1. defer的规则

**规则一：延迟函数的参数在defer语句出现时就已经确定下来了**

```go
func a() {
    i := 0
    defer fmt.Println(i)
    i++
    return
}
```

defer语句中的`fmt.Println()`参数`i`值在defer出现的时候就已经确定下来了，实际上拷贝了一份。后面对变量i的修改不会影响`fmt.Println()`函数的执行。

但是，对于指针类型参数，规则仍然适用，只不过延迟函数的参数就是一个地址值，这种情况下，defer后面的语句对变量的修改可能会影响延迟函数。

**规则二：延迟函数执行按后进先出顺序执行，即先出现的defer最后执行**

定义defer类似于入栈操作，执行defer类似于出栈操作。

设计defer的初衷是简化函数返回时资源清理的动作，资源往往有依赖顺序，比如先申请A资源，再根据A资源申请B资源，根据B资源申请C资源，即申请顺序是：A->B->C，释放时往往又要反方向进行。

**规则三：延迟函数可能操作主函数的具名返回值**

定义defer的函数，即主函数可能有返回值，返回值有没有名字没有关系，defer所作用的函数，即延迟函数可能会影响到返回值。

这时我们就需要搞懂函数是如何返回的？

#### 1.1 函数返回的过程

有个事实必须要了解，关键字return不是一个原子操作，实际上return只代理汇编指令ret，即将跳转程序执行。比如语句`return i`，实际上分为两步执行，即将i值存入栈中作为返回值，然后执行跳转，而defer的执行时机正是跳转前，所以说defer执行还是有机会操作返回值的。（栈空间用来存放函数参数和局部变量，由系统分配）

举个例子说明这个过程

```go
func deferFuncReturn()(result int) {
    i := 1
    defer func() {
       result++ 
    }()
    return i
}
```

该函数的return语句可以拆分为下面两行：

```go
result = i
return
```

而延迟函数的执行正是在return之前，即加入defer后的执行过程如下：

```go
result = i
result++
return
```

所以上面函数实际返回i++值。

#### 1.2 主函数拥有匿名返回值，返回变量

一个主函数拥有一个匿名的返回值，返回使用本地或全局变量，这种情况下defer语句可以引用到返回值，但不会改变返回值。

一个返回本地变量的函数，如下所示

```go
func foo() int {
    var i int
    
    defer func(){
        i++
    }()
    return i
}
```

上面的函数，返回一个局部变量，同时defer函数也会操作这个局部变量。对于匿名返回值来说，可以假定仍然有一个变量存储返回值，假定返回值变量为"anony"，上面的返回语句可以拆分成一下过程：

```go
anony = i
i++
return
```

由于`i`是整型，会将值拷贝给`anony`，所以defer语句中修改`i`值，对函数返回值不会造成影响。（所以defer中的匿名函数操作的还是局部变量`i`）

#### 1.3 主函数拥有具名返回值

```go
func foo() (ret int) {
    defer func(){
        ret++
    }()
    
    return 0
}
```

根据对函数返回值的理解

```go
ret = 0
ret++
return
```

函数真正返回前，在defer中对返回值做了`+1`操作，所以函数最终返回1

### 2. defer实现原理

#### 2.1 defer数据结构

```go
type _defer struct {
    sp      uintptr   //函数栈指针
    pc      uintptr   //程序计数器
    fn      *funcval  //函数地址
    link    *_defer   //指向自身结构的指针，用于链接多个defer
}
```

因为defer后面一定要接一个函数，所以defer的数据结构跟一般函数类似，也有栈地址、程序计数器、函数地址等。

但是defer还有一个指针，可用来指向另一个defer，每个goroutine数据结构中实际上也有一个defer指针，该指针指向一个defer的单链表，每次声明一个defer时就将defer插入到单链表表头，每次执行defer时就从单链表表头取出一个defer执行。

下图展示多个defer被链表的过程：

![image-20210817143024593](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210817143024593.png)

从上图可以看到，新声明的defer总是添加到链表头部。函数返回执行defer则是从链表首部依次取出执行。

### 总结

* defer定义的延迟函数参数在defer语句出现时就已经确定下来了
* defer定义顺序与实际执行顺序相反
* return不是原子操作，执行过程是：保存返回值（若有）->执行defer（若有）->执行ret跳转
* 申请资源后立即使用defer关闭资源是好习惯。